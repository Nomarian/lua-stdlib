before:
  this_module = "std.strbuf"

  StrBuf = require (this_module).prototype
  b      = StrBuf {"foo", "bar"}

  setdebug { deprecate = false }

  deprecate_on = bind (deprecation, {"nil", this_module})
  deprecate_off = bind (deprecation, {false, this_module})

specify std.strbuf:
- describe require:
  - it does not perturb the global namespace:
      expect (show_apis {added_to="_G", by="std.strbuf"}).
        to_equal {}


- describe construction:
  - context from StrBuf clone method:
    - it constructs a new strbuf:
        b = StrBuf:clone {}
        expect (b).not_to_be (StrBuf)
        expect (objtype (b)).to_be "StrBuf"
    - it reuses the StrBuf metatable:
        a, b = StrBuf:clone {"a"}, StrBuf:clone {"b"}
        expect (getmetatable (a)).to_be (getmetatable (b))
    - it initialises strbuf with constructor parameters:
        a = StrBuf:clone {"foo", "bar"}
        expect (a).to_equal (b)
    - it serves as a prototype for new instances:
        obj = b:clone {}
        expect (objtype (obj)).to_be "StrBuf"
        expect (obj).to_equal (b)
        expect (getmetatable (obj)).to_be (getmetatable (b))

  # StrBuf {args} is just syntactic sugar for StrBuf:clone {args}
  - context from StrBuf object prototype:
    - it constructs a new strbuf:
        b = StrBuf {}
        expect (b).not_to_be (StrBuf)
        expect (objtype (b)).to_be "StrBuf"
    - it reuses the StrBuf metatable:
        a, b = StrBuf {"a"}, StrBuf {"b"}
        expect (getmetatable (a)).to_be (getmetatable (b))
    - it initialises strbuf with constructor parameters:
        a = StrBuf:clone {"foo", "bar"}
        expect (a).to_equal (b)
    - it serves as a prototype for new instances:
        obj = b {}
        expect (objtype (obj)).to_be "StrBuf"
        expect (obj).to_equal (b)
        expect (getmetatable (obj)).to_be (getmetatable (b))


- describe tostring:
  - context as a module function:
    - it writes a deprecation warning:
        expect (deprecate_on ("tostring", "P {'foo', 'bar'}")).
          to_contain_error "was deprecated"
        expect (deprecate_off ("tostring", "P {'foo', 'bar'}")).
          not_to_contain_error "was deprecated"

    - it returns buffered string:
        expect (StrBuf.tostring (b)).to_be "foobar"

  - context as an object method:
    - it writes a deprecation warning:
        expect (deprecate_on ("tostring", "", "{'foo', 'bar'}")).
          to_contain_error "was deprecated"
        expect (deprecate_off ("tostring", "", "{'foo', 'bar'}")).
          not_to_contain_error "was deprecated"

    - it returns buffered string:
        expect (b:tostring ()).to_be "foobar"

  - context as a metamethod:
    - it returns buffered string:
        expect (tostring (b)).to_be "foobar"


- describe concat:
  - before:
      a = StrBuf {"foo", "bar"}
      b = StrBuf {"baz", "quux"}

  - context as a module function:
    - it appends a string:
        a = StrBuf.concat (a, "baz")
        expect (objtype (a)).to_be "StrBuf"
        expect (tostring (a)).to_be "foobarbaz"
    - it appends a StrBuf:
        a = StrBuf.concat (a, b)
        expect (objtype (a)).to_be "StrBuf"
        expect (tostring (a)).to_be "foobarbazquux"
  - context as an object method:
    - it appends a string:
        a = a:concat "baz"
        expect (objtype (a)).to_be "StrBuf"
        expect (tostring(a)).to_be "foobarbaz"
    - it appends a StrBuf:
        a = a:concat (b)
        expect (objtype (a)).to_be "StrBuf"
        expect (tostring (a)).to_be "foobarbazquux"
  - context as a metamethod:
    - it appends a string:
        a = a .. "baz"
        expect (objtype (a)).to_be "StrBuf"
        expect (tostring (a)).to_be "foobarbaz"
    - it appends a StrBuf:
        a = a .. b
        expect (objtype (a)).to_be "StrBuf"
        expect (tostring (a)).to_be "foobarbazquux"
  - it stringifies lazily:
      a = StrBuf {1}
      b = StrBuf {a, "five"}
      a = a:concat (2)
      expect (tostring (b)).to_be "12five"
      b = StrBuf {tostring (a), "five"}
      a = a:concat (3)
      expect (tostring (b)).to_be "12five"
  - it can be non-destructive:
      a = StrBuf {1}
      b = a {} .. 2
      expect (tostring (a)).to_be "1"


- describe __pickle:
  - before:
      loadstring = loadstring or load
      function unpickle (s) return loadstring ("return " .. s) () end
      f = require "std.string".pickle

      Derived = StrBuf {_type = "Derived"}
      things = Derived {false, "str", 42}

  - it returns a string:
      expect (type (f (things))).to_be "string"
  - it resets '_module' metafield when '_type' changes:
      expect (getmetatable (things)._module).to_be (nil)
  - it supports setting '_module' and '_type' metafields:
      Everything = Derived { _type = "Everything", _module = "nearly" }
      expect (objtype (Everything)).to_be "Everything"
      expect (getmetatable (Everything)._module).to_be "nearly"
      Everything = StrBuf { _type = "Everything", _module = "nearly" }
      expect (objtype (Everything)).to_be "Everything"
      expect (getmetatable (Everything)._module).to_be "nearly"
  - it does not have a period in '_type':
      Period = Derived { _type = "specs.example.Period" }
      expect (string.find (type (Period), "%.")).to_be (nil)
  - it propagates the '_module' metafield when '_type' is unchanged:
      expect (getmetatable (StrBuf {1})._module).
        to_be (getmetatable (StrBuf)._module)
  - context with '_module' metafield:
    - it requires the module path for later invocation:
        expect (f (StrBuf)).to_be 'require "std.strbuf".prototype {}'
    - it roundtrips objects:
        expect (unpickle (f (StrBuf))).to_equal (StrBuf)
  - context with '_type' metafield only:
    - it uses the '_type' value for later invocation:
        expect (f (things)).to_be 'Derived {[1]=false,[2]="str",[3]=42}'
    - it roundtrips objects:
        compat = require "specl.compat"
        compat.setfenv (unpickle, compat.getfenv (1))
        expect (unpickle (f (things))).to_equal (things)
  - it converts a nested object to a representative string:
      buf = StrBuf {Derived {"?"}, ["!"]=42}
      expect (f (buf)).
        to_be 'require "std.strbuf".prototype {[1]=Derived {[1]="?"},["!"]=42}'
  - it roundtrips nested objects:
        buf = StrBuf {Derived {"?"}, ["!"]=42}
        expect (unpickle (f (buf))).to_equal (buf)
